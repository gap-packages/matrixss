Revision.code_gi := "@(#)$Id$";

# The action of a group element g (a matrix) on a point p (a row vector)
# The action is from the right
# Used in Matrix Schreier-Sims
MSSAction := function(element, point)
    
    if not IsMatrix(element) or not IsRowVector(point) then
        Error("<element> must be a matrix and <point> must be a row vector");
    fi;
    
    return point * element;
end;

# Helper function for SchreierTree.
ComputeSchreierTree := function(generators, root, action, tree)
    local newElement, childElements, generator, child;
        
    childElements := [];
    for generator in generators do
        newElement := action(generator, root);
        if not newElement = root then
            AddHashEntry(tree, newElement, generator);
            Add(childElements, newElement);
        fi;
    od;
    
    # compute children schreier trees
    for child in childElements do
        ComputeSchreierTree(generators, child, action, tree);
    od;
        
end;      
    
# Computes a Schreier tree 
# root - root of the Schreier tree
# generators - generators for group
# points - point set where root comes from
# action - the action used to create the tree
#
# This is just a computation of a spanning tree for a connected component
SchreierTree := function(generators, points, root, action, identity)
    local tree;
    
    # Create Schreier vector
    tree := SparseHashTable(SparseIntKey(points, root));
    
    # Make the root point to itself 
    AddHashEntry(tree, root, identity);
    
    # Fill Schreier vector
    return ComputeSchreierTree(generators, root, action);                   
end;

SchreierTreeLookup := function(schreierTree, point)
    return GetHashEntry(schreierTree, point);
end;

# Compute the group element that connects the root of the Schreier tree to
# a given point
OrbitElement := function(schreierTree, identity, point, action)
    local edge;
    
    edge := SchreierTreeLookup(schreierTree, point);
    if not edge = identity then
        return OrbitElement(schreierTree, identity, 
                       action(Inverse(edge), point), action) * edge;
    else
        return identity;
    fi;
end;

# return all points (as a list) in the orbit of the point 
# which is root of the schreier tree
GetOrbit := function(schreierTree)
    return HashKeyEnumerator(schreierTree);
end;

IsPointInOrbit := function(schreierTree, point)
    if GetHashEntry(schreierTree, point) then
        return true;
    else
        return false;
    fi;
    
end;

GetSchreierTreeEdge := function(schreierTree, point)
    return GetHashEntry(schreierTree, point);
end;
    
# return generating set of a point
# generators - generating set for group to compute in
# root - point to compute stabiliser of
# schreierTree - have root as root
Stabiliser := function(generators, root, schreierTree, action, identity)
    local stabiliser, orbit, element1, element2, generator, point, edge;
    
    stabiliser := [];
    orbit := GetOrbit(schreierTree);
    
    for generator in generators do
        for point in orbit do
            if not GetSchreierTreeEdge(schreierTree, point) = generator then
                element1 := OrbitElement(schreierTree, identity,
                                    point, action);
                element2 := OrbitElement(schreierTree, identity,
                                    action(Inverse(generator), point), action);
                AddSet(stabiliser, element2 * generator * Inverse(element1));
            fi;
        od;
    od;
    
    return stabiliser;
end;

    
# Recursive Schreier-Sims over matrix group generated by S
# partialBase - a partial base
# partialSGS - a partial strong generating set
SchreierSims := function(partialBase, partialSGS, action)
    local newBase, newSGS, ret, element;
    
    if IsEmpty(partialSGS) then
       return [partialBase, partialSGS];
    fi;
    
    repeat
        newBase := partialBase{[2 .. Length(partialBase)]};
        newSGS  := [];
        for element in partialSGS do
            if action(element, partialBase[1]) = partialBase[1] then
                AddSet(newSGS, element);
            fi;
        od;
        
        ret     := SchreierSims(newBase, newSGS, action);
        newBase := ret[1];
        newSGS  := ret[2];
        
        partialBase := partialBase{[1]};
        Append(partialBase, newBase);
        UniteSet(partialSGS, newSGS);
        
        
    until true;
    
end;

# An implementation of the Schreier-Sims algorithm, for matrix groups
MatrixSchreierSims := function(G)
    local S, B;

    if not IsMatrixGroup(G) then
        Error("<G> must be a matrix group");
    fi;
    
    S := GeneratorsOfGroup(G);
    B := BasisVectors(CanonicalBasis(FullRowSpace(FieldOfMatrixGroup(G), 
                 DimensionOfMatrixGroup(G))));
    
    # if S does not contain the identity, then S is a partial SGS
    
    return SchreierSims(B, S, MSSAction);
end;
